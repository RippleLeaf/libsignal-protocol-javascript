\documentclass{article}
\usepackage[utf8]{inputenc}

\title{CS6431 Project Report}
\author{Wei-kai Lin, Yue Guo}
% \date{February 2018}

\usepackage{natbib}
% \usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath,amsthm,amstext,amssymb,amsfonts,latexsym}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{geometry}
% \geometry{left=3cm, right=3cm, top=3.5cm, bottom=3.5cm}
\usepackage{comment}
\usepackage{enumitem}
\usepackage{color}
\usepackage{parskip} % Remove paragraph indentation

\usepackage{pgfplots}
\pgfplotsset{width = 5.9cm, compat=1.5}

\definecolor{blue1}{rgb}{0.4,0.4,0.7}
\definecolor{blue2}{rgb}{0.3,0.3,0.8}
\definecolor{blue3}{rgb}{0.2,0.2,0.9}

\newcommand{\yue}[1]{\textcolor{red}{[yue: #1]}}
\newcommand{\weikai}[1]{\textcolor{blue}{[weikai: #1]}}

\begin{document}
\maketitle

\begin{abstract}
    
\end{abstract}

\section{Introduction}

\section{Related Work}
\subsection{Facebook}


\section{Implementation of Message Franking}

Adding message franking to an existing end-to-end encrypted
messaging protocol incurs interface change on both client and server side.
The interface of Sender ({\tt encrypt}) doesn't change,
which takes as input a plaintext
although outputs a cipher message in a new format.
However, the interface of Receiver ({\tt decrypt}),
after takes as input a cipher message,
outputs not only a plaintext but also an opening or \emph{proof},
where the proof is needed 
whenever Receiver wants to report the plaintext to Server.
Finally, to verify a pair of plaintext and proof,
in our implementation,
Server \emph{forwards and tags} the cipher message in the sending phase,
and thus it is necessary to use the new format of the cipher message
to efficiently compute the tag.
In the following, we describe such interface and its usage,
and then, some implementation details are shown 
regarding the security and efficiency.
\weikai{define sending phase and reporting phase}

\subsection{New Interfaces of Library}

We implement Committing Encrypt-then-PRF on {\tt libsignal-protocol-javascript},
the Signal Protocol library for JavaScript.
The following interface works directly in JavaScript,
but it is straightforward to 
implement them on the library for Java or for C
given that it was already implemented using Protocol Buffers\footnote{
See https://developers.google.com/protocol-buffers/.
}.
\weikai{define CEP}


\paragraph{Client-side Interface: Output of {\tt decryptWhisperMessage}.}
In this paragraph, 
we describe the change of return type of {\tt decryptWhisperMessage},
the function that handling decryption.
The interface of session-building and encryption are unchanged
and deferred to the Usage part (Section~\ref{sec:usage}).

The function call to decrypt a chiper message works a follows,
where {\tt ciphertext} is the object returned by the encryption,
and {\tt plaintext} is an array of bytes.
{\small
\begin{verbatim}
sessionCipher.decryptWhisperMessage(ciphertext.body, "binary").then(function (plaintext) {
    console.log(plaintext);
});
\end{verbatim}
}
However, with Message Franking implemented,
we augment the plaintext into a structure:
{\small
\begin{verbatim}
{
    header: ArrayBuffer,         // metadata, returned for HMAC verification
    body: ArrayBuffer,           // the original plaintext
    commitKey: ArrayBuffer(32),  // commitKey and commitment, to verify, check
    commitment: ArrayBuffer(32)  // HMAC(commitKey, concat of (header, body)) == commitment
}
\end{verbatim}
}
Note that such returned structure doesn't include a server generated tag,
which depends on how does Server verify the {\tt commitment}.
It is defined in the following paragraph.

\paragraph{Server-side Interface.}
In scheme of CEP, Server needs to ``know'' 
the {\tt commitment} of each cipher message
in order to verify the plaintext.
In the implementation, 
Server computes a tag of {\tt commitment} using its secret key,
and then forwards both cipher message and tag to Receiver.
We modify the format of cipher messages as follows,
where {\tt mac}, {\tt commitment} and {\tt tag}
are modified for Message Franking.
{\small
\begin{verbatim}
{
    type: Unit8, 
    body: ArrayBuffer, concatenation of
        version: 1 byte,
        message: serialized Protocol Buffer of
            ephemeralKey: bytes,
            counter: uint32, 
            previousCounter: uint32, 
            ciphertext: bytes
        mac: 32 bytes,                          // 8 bytes in original format
        commitment: 32 bytes                    // new entry
    registrationId: Uint32, 
    tag: ArrayBuffer(32)                        // generated by Server
}
\end{verbatim}
}




\subsection{Usage}



\subsection{Security and Implementation Details}






\input{discussion}






\bibliographystyle{plain}
\bibliography{references}
\end{document}
